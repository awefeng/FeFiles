### 大文件上传

https://juejin.cn/post/6844904046436843527#heading-24

要点：

1. 浏览器文件分片：`Blob.prototype.slice`，将大文件拷贝后生成若干个小文件

   ```javascript
   const FILE_CHUNK_SIZE = 10 * 1024 * 1024 // 10M
   const createFileChunk = (file) => {
     const chunkCounts = Math.ceil(file.size/FILE_CHUNK_SIZE)
     let cur = 0, chunks = []
     while(cur < chunkCounts){
   		chunks.push({file: file.slice(FILE_CHUNK_SIZE*cur, FILE_CHUNK_SIZE*(cur+1))})
       cur++
     }
     
     return chunks
   }
   ```

   

2. 上传分片

   ```javascript
   const uploadChunk = (chunk) => {
   	fetch(api, chunk)
   }
   
   const allUpload = async () => {
    return  chunks.map(async chunk => {
   		await uploadCHunk(chunk)
   	})
   }
   
   await Promise.all(allUpload())
   
   ```

   

3. 服务端合并分片：上传分片，每一次请求发送总的分片数量或者所有分片上传完成后发送合并文件请求。

断电续传：

分片后计算文件hash值，将hash值先传入服务端。后面继续上传的时候，先校验哪些文件是传入完整的，浏览器就知道哪些分片上传了哪些没有上传。



### 虚拟列表

原理：计算出可视窗口渲染元素个数，然后通过监听滚动设置偏移量，动态生成可视窗口里的元素。

1. 先确认两个端口，一个是可视窗口或者是渲染窗口A高度，一个是虚拟列表B总高度
2. 计算出能够渲染的元素个数。
3. 监听滚动，计算出偏移量。
4. 偏移量计算出后，计算处于偏移量当前的元素，重新挂载。



优化： 计算出偏移量以后，进行缓存，某个Index对应的offset是多少。后面再滚动的时候就不用计算。



都是首先计算出视窗A高度，子元素高度，然后计算出能显示的个数，两个div，一个是A的高度，还有一个是整个list的高度，然后根据渲染的scrollTop来确定当前渲染哪些元素。

https://lkangd.com/post/virtual-infinite-scroll/





### Promise式的Ajax


#### React-Router中的单例和监听模式

单例

```javascript
const single = (function (){
    let instantce
    return function(className, args){
        if(instantce){
            return instantce
        }else{
            instantce = new className(...args)
            return instantce
        }
    }
})()

```



#### JS的同步链式调用

```javascript
class People{
  constructor(name){
    console.log(`People ${name} init`)
  }
  
  do(thing){
    console.log(`Start to do ${thing}`)
    return this
  }
}

const a = new People('awefeng')

a.do('eat').do('run')
```



#### Promise实现一个等待5s

```javascript
async function timeout(interval){
  await new Promise((reslve)=> setTimeout(resolve, interval))
}
```



#### JS的异步链式调用

```javascript
function arrange(name){
  const people = {}
  let promise = Promise.resolve()

  people.do = function(thing){
    promise = promise.then(()=>console.log(`Start to do ${thing}`))
    //console.log(`Start to do ${thing}`)
    return people
  }
  people.wait = function(times){
    promise = promise.then(async ()=>{
      console.log(`Wait for ${times}s `)
      await new Promise((resolve)=>setTimeout(resolve, times*1000))
    })
    return people
  }
  people.execute = function(){
    console.log(`${name} is notified`)
    return people
  }
  return people
}

//arrange('william').execute()

arrange('wu').do('eat').wait(5).do('run').execute()
```

